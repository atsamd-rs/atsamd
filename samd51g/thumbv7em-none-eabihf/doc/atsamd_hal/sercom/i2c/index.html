<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Use the SERCOM peripheral for I2C communications"><title>atsamd_hal::sercom::i2c - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="atsamd_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../../static.files/storage-82c7156e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../atsamd_hal/index.html">atsamd_<wbr>hal</a><span class="version">0.22.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module i2c</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#pads" title="`Pads`"><code>Pads</code></a></li><li><a href="#config" title="`Config`"><code>Config</code></a><ul><li><a href="#reading-the-current-configuration" title="Reading the current configuration">Reading the current configuration</a></li></ul></li><li><a href="#i2c" title="`I2c`"><code>I2c</code></a></li><li><a href="#reading-the-current-configuration-1" title="Reading the current configuration">Reading the current configuration</a></li><li><a href="#reconfiguring" title="Reconfiguring">Reconfiguring</a></li><li><a href="#non-supported-features" title="Non-supported features">Non-supported features</a></li><li><a href="#using-i2c-with-dma-dma" title="Using I2C with DMA dma">Using I2C with DMA dma</a><ul><li><a href="#limitations-of-using-dma-with-i2c" title="Limitations of using DMA with I2C">Limitations of using DMA with I2C</a></li></ul></li><li><a href="#async-operation-async" title="`async` operation async"><code>async</code> operation async</a><ul><li><a href="#considerations-when-using-async-i2c-with-dma-async-dma" title="Considerations when using `async` `I2c` with DMA async dma">Considerations when using <code>async</code> <code>I2c</code> with DMA async dma</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In atsamd_<wbr>hal::<wbr>sercom</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">atsamd_hal</a>::<wbr><a href="../index.html">sercom</a></div><h1>Module <span>i2c</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/atsamd_hal/sercom/i2c.rs.html#1-589">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Use the SERCOM peripheral for I2C communications</p>
<p>Configuring an I2C peripheral occurs in three steps. First, you must create
a set of <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> for use by the peripheral. Next, you assemble pieces into
a <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> struct. After configuring the peripheral, you then <a href="struct.Config.html#method.enable" title="method atsamd_hal::sercom::i2c::Config::enable"><code>enable</code></a>
it, yielding a functional <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct. Transactions are performed using
traits from embedded-hal (<a href="../../../embedded_hal/index.html" title="mod embedded_hal">v1.0</a> and blocking traits from
<a href="../../../embedded_hal/index.html" title="mod embedded_hal">v0.2</a>).</p>
<h2 id="pads"><a class="doc-anchor" href="#pads">§</a><a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a></h2>
<p>A <a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a> uses two <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s as peripheral <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a>s, but only certain
<a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a> combinations are acceptable. All <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s must be mapped to the same
<a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a>, and SDA is always <a href="../pad/enum.Pad0.html" title="enum atsamd_hal::sercom::pad::Pad0"><code>Pad0</code></a>, while SCL is always <a href="../pad/enum.Pad1.html" title="enum atsamd_hal::sercom::pad::Pad1"><code>Pad1</code></a> (see
the datasheet). SAMx5x chips have an additional constraint that <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s
must be in the same <a href="../pad/trait.IoSet.html" title="trait atsamd_hal::sercom::pad::IoSet"><code>IoSet</code></a>.  This HAL makes it impossible to use invalid
<a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>/<a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a> combinations, and the <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> struct is responsible for
enforcing these constraints.</p>
<p>A <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> type takes three type parameters. The first type specifies the
<a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a>, <code>SDA</code> and <code>SCL</code> represent the SDA and SCL pads respectively. A
<a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a> is just a <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a> configured in the correct <a href="../../gpio/pin/trait.PinMode.html" title="trait atsamd_hal::gpio::pin::PinMode"><code>PinMode</code></a> that
implements <a href="../pad/trait.IsPad.html" title="trait atsamd_hal::sercom::pad::IsPad"><code>IsPad</code></a>. The <a href="../../macro.bsp_pins.html" title="macro atsamd_hal::bsp_pins"><code>bsp_pins!</code></a> macro can be used
to define convenient type aliases for <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a> types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::gpio::{PA08, PA09, AlternateC};
<span class="kw">use </span>atsamd_hal::sercom::{Sercom0, i2c};
<span class="kw">use </span>atsamd_hal::typelevel::NoneT;

<span class="kw">type </span>Sda = Pin&lt;PA08, AlternateC&gt;;
<span class="kw">type </span>Scl = Pin&lt;PA09, AlternateC&gt;;

<span class="kw">type </span>Pads = i2c::Pads&lt;Sercom0, Sda, Scl&gt;;</code></pre></div>
<p>Alternatively, you can use the <a href="type.PadsFromIds.html" title="type atsamd_hal::sercom::i2c::PadsFromIds"><code>PadsFromIds</code></a> alias to define a set of
<code>Pads</code> in terms of <a href="../../gpio/pin/trait.PinId.html" title="trait atsamd_hal::gpio::pin::PinId"><code>PinId</code></a>s instead of <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s. This is useful when you
don’t have <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a> aliases pre-defined.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::gpio::{PA08, PA09};
<span class="kw">use </span>atsamd_hal::sercom::{Sercom0, i2c};

<span class="kw">type </span>Pads = i2c::PadsFromIds&lt;Sercom0, PA08, PA09&gt;;</code></pre></div>
<p>Instances of <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> are created using the <a href="struct.Pads.html#method.new" title="associated function atsamd_hal::sercom::i2c::Pads::new"><code>new</code></a> method.</p>
<p>On SAMD21 and SAMx5x chips, <a href="struct.Pads.html#method.new" title="associated function atsamd_hal::sercom::i2c::Pads::new"><code>new</code></a> method automatically convert
each pin to the correct <a href="../../gpio/pin/trait.PinMode.html" title="trait atsamd_hal::gpio::pin::PinMode"><code>PinMode</code></a>. But for SAMD11 chips, users must
manually convert each pin before calling the builder methods. This is a
consequence of inherent ambiguities in the SAMD11 SERCOM pad definitions.
Specifically, the same <a href="../../gpio/pin/trait.PinId.html" title="trait atsamd_hal::gpio::pin::PinId"><code>PinId</code></a> can correspond to two different <a href="../pad/trait.PadNum.html" title="trait atsamd_hal::sercom::pad::PadNum"><code>PadNum</code></a>s
for the <em>same</em> <code>Sercom</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::pac::Peripherals;
<span class="kw">use </span>atsamd_hal::gpio::Pins;
<span class="kw">use </span>atsamd_hal::sercom::{Sercom0, i2c};

<span class="kw">let </span><span class="kw-2">mut </span>peripherals = Peripherals::take().unwrap();
<span class="kw">let </span>pins = Pins::new(peripherals.PORT);
<span class="kw">let </span>pads = i2c::Pads::&lt;Sercom0&gt;::new(pins.pa08, pins.pa09);</code></pre></div>
<h2 id="config"><a class="doc-anchor" href="#config">§</a><a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a></h2>
<p>Next, create a <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> struct, which represents the I2C peripheral in its
disabled state. A <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> is specified with one type parameters, the
<a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> type.</p>
<p>Upon creation, the <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> takes ownership of both the <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> struct
and the PAC <a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a> struct. It takes a reference to the PM, so that it
can enable the APB clock, and it takes a frequency to indicate the GCLK
configuration. Users are responsible for correctly configuring the GCLK.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::gpio::{PA08, PA09};
<span class="kw">use </span>atsamd_hal::sercom::{Sercom0, i2c};

<span class="kw">type </span>Pads = i2c::PadsFromIds&lt;Sercom0, PA08, PA09&gt;;
<span class="kw">type </span>Config = i2c::Config&lt;Pads&gt;;

<span class="kw">let </span>pm = peripherals.PM;
<span class="kw">let </span>sercom = peripherals.SERCOM0;
<span class="comment">// Configure GCLK for 10 MHz
</span><span class="kw">let </span>freq = <span class="number">10</span>.mhz();
<span class="kw">let </span>config = i2c::Config::new(<span class="kw-2">&amp;</span>pm, sercom, pads, freq);</code></pre></div>
<p>The <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> struct can configure the peripheral in one of two ways:</p>
<ul>
<li>A set of methods is provided to use in a builder pattern: for example
<a href="struct.Config.html#method.baud" title="method atsamd_hal::sercom::i2c::Config::baud"><code>baud</code></a>, <a href="struct.Config.html#method.run_in_standby" title="method atsamd_hal::sercom::i2c::Config::run_in_standby"><code>run_in_standby</code></a>, etc.
These methods take <code>self</code> and return <code>Self</code>.</li>
<li>A set of methods is provided to use as setters: for example
<a href="struct.Config.html#method.set_baud" title="method atsamd_hal::sercom::i2c::Config::set_baud"><code>set_baud</code></a>,
<a href="struct.Config.html#method.set_run_in_standby" title="method atsamd_hal::sercom::i2c::Config::set_run_in_standby"><code>set_run_in_standby</code></a>, etc. These methods
take <code>&amp;mut self</code> and return nothing.</li>
</ul>
<p>In any case, the peripheral setup ends with a call to <a href="struct.Config.html#method.enable" title="method atsamd_hal::sercom::i2c::Config::enable"><code>enable</code></a>, which
consumes the <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> and returns an enabled <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> peripheral.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>i2c = i2c::Config::new(<span class="kw-2">&amp;</span>pm, sercom, pads, freq)
    .baud(<span class="number">1</span>.mhz())
    .enable();</code></pre></div>
<p>Alternatively,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>i2c = i2c::Config::new(<span class="kw-2">&amp;</span>mclk, sercom, pads, freq);
    i2c.set_baud(<span class="number">1</span>.mhz());
    <span class="kw">let </span>i2c = i2c.enable();</code></pre></div>
<h3 id="reading-the-current-configuration"><a class="doc-anchor" href="#reading-the-current-configuration">§</a>Reading the current configuration</h3>
<p>It is possible to read the current configuration by using the getter methods
provided: for example <a href="struct.Config.html#method.get_baud" title="method atsamd_hal::sercom::i2c::Config::get_baud"><code>get_baud</code></a>,
<a href="struct.Config.html#method.get_run_in_standby" title="method atsamd_hal::sercom::i2c::Config::get_run_in_standby"><code>get_run_in_standby</code></a>, etc.</p>
<h2 id="i2c"><a class="doc-anchor" href="#i2c">§</a><a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a></h2>
<p><a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> structs can only be created from a <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a>. They have one type
parameter, representing the underlying <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a>.</p>
<p>Only the <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct can actually perform transactions. To do so, use the
<a href="../../../embedded_hal/i2c/trait.I2c.html" title="trait embedded_hal::i2c::I2c"><code>embedded_hal::i2c::I2c</code></a> trait.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>embedded_hal::i2c::I2c;

i2c.write(<span class="number">0x54</span>, <span class="number">0x0fe</span>).unwrap();</code></pre></div>
<h2 id="reading-the-current-configuration-1"><a class="doc-anchor" href="#reading-the-current-configuration-1">§</a>Reading the current configuration</h2>
<p>The <code>AsRef&lt;Config&lt;P&gt;&gt;</code> trait is implemented for <code>I2c&lt;Config&lt;P&gt;&gt;</code>. This means
you can use the <code>get_</code> methods implemented for <code>Config</code>, since they take an
<code>&amp;self</code> argument.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Assume i2c is a I2c&lt;C&lt;P&gt;&gt;
</span><span class="kw">let </span>baud = i2c.as_ref().get_baud();</code></pre></div>
<h2 id="reconfiguring"><a class="doc-anchor" href="#reconfiguring">§</a>Reconfiguring</h2>
<p>The <a href="struct.I2c.html#method.reconfigure" title="method atsamd_hal::sercom::i2c::I2c::reconfigure"><code>reconfigure</code></a> method gives out an <code>&amp;mut Config</code> reference, which can
then use the <code>set_*</code> methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::sercom::i2c::I2c;

<span class="comment">// Assume config is a valid Duplex I2C Config struct
</span><span class="kw">let </span>i2c = config.enable();

<span class="comment">// Send/receive data...

// Reconfigure I2C peripheral
</span>i2c.reconfigure(|c| c.set_run_in_standby(<span class="bool-val">false</span>));

<span class="comment">// Disable I2C peripheral
</span><span class="kw">let </span>config = i2c.disable();</code></pre></div>
<h2 id="non-supported-features"><a class="doc-anchor" href="#non-supported-features">§</a>Non-supported features</h2>
<ul>
<li>Slave mode is not supported at this time.</li>
<li>High-speed mode is not supported.</li>
<li>4-wire mode is not supported.</li>
<li>32-bit extension mode is not supported (SAMx5x). If you need to transfer
slices, consider using the DMA methods instead <span class="stab
portability" title="Available on crate feature `dma`
only"><code>dma</code></span>.</li>
</ul>
<h2 id="using-i2c-with-dma-dma"><a class="doc-anchor" href="#using-i2c-with-dma-dma">§</a>Using I2C with DMA <span class="stab portability" title="Available on crate feature `dma` only"><code>dma</code></span></h2>
<p>This HAL includes support for DMA-enabled I2C transfers. Use
<a href="struct.I2c.html#method.with_dma_channel" title="method atsamd_hal::sercom::i2c::I2c::with_dma_channel"><code>I2c::with_dma_channel</code></a> to attach a DMA channel to the <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct. A
DMA-enabled <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> implements the blocking
<a href="../../../embedded_hal/i2c/trait.I2c.html" title="trait embedded_hal::i2c::I2c"><code>embedded_hal::i2c::I2c</code></a> trait, which can be used
to perform I2C transfers which are fast, continuous and low jitter, even if
they are preemped by a higher priority interrupt.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::dmac::channel::{AnyChannel, Ready};
<span class="kw">use </span>atsand_hal::sercom::i2c::{I2c, AnyConfig, Error};
<span class="kw">use </span>atsamd_hal::embedded_hal::i2c::I2c;
<span class="kw">fn </span>i2c_write_with_dma&lt;A: AnyConfig, C: AnyChannel&lt;Status = Ready&gt;&gt;(i2c: I2c&lt;A&gt;, channel: C, bytes: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt;{
    <span class="comment">// Attach a DMA channel
    </span><span class="kw">let </span>i2c = i2c.with_dma_channel(channel);
    i2c.write(<span class="number">0x54</span>, bytes)<span class="question-mark">?</span>;
}</code></pre></div>
<h3 id="limitations-of-using-dma-with-i2c"><a class="doc-anchor" href="#limitations-of-using-dma-with-i2c">§</a>Limitations of using DMA with I2C</h3>
<ul>
<li>
<p>The I2C peripheral only supports continuous DMA read/writes of up to 255
bytes. Trying to read/write with a transfer of 256 bytes or more will
result in a panic. This also applies to using <a href="../../../embedded_hal/i2c/trait.I2c.html#tymethod.transaction" title="method embedded_hal::i2c::I2c::transaction"><code>I2c::transaction</code></a> with
adjacent write/read operations of the same type; the total number of bytes
across all adjacent operations must not exceed 256. If you need continuous
transfers of 256 bytes or more, use the non-DMA <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> implementations.</p>
</li>
<li>
<p>When using <a href="../../../embedded_hal/i2c/trait.I2c.html#tymethod.transaction" title="method embedded_hal::i2c::I2c::transaction"><code>I2c::transaction</code></a> or <a href="../../../embedded_hal/i2c/trait.I2c.html#method.write_read" title="method embedded_hal::i2c::I2c::write_read"><code>I2c::write_read</code></a>, the
<a href="../../../embedded_hal/i2c/trait.I2c.html" title="trait embedded_hal::i2c::I2c"><code>embedded_hal::i2c::I2c</code></a> specification mandates that a REPEATED START
(instead of a STOP+START) is sent between transactions of a different type
(read/write). Unfortunately, in DMA mode, the hardware is only capable of
sending STOP+START. If you absolutely need repeated starts, the only
workaround is to use the I2C without DMA.</p>
</li>
<li>
<p>Using <a href="../../../embedded_hal/i2c/trait.I2c.html#tymethod.transaction" title="method embedded_hal::i2c::I2c::transaction"><code>I2c::transaction</code></a> consumes significantly more memory than the
other methods provided by <a href="../../../embedded_hal/i2c/trait.I2c.html" title="trait embedded_hal::i2c::I2c"><code>embedded_hal::i2c::I2c</code></a> (at least 256 bytes
extra).</p>
</li>
<li>
<p>When using <a href="../../../embedded_hal/i2c/trait.I2c.html#tymethod.transaction" title="method embedded_hal::i2c::I2c::transaction"><code>I2c::transaction</code></a>, up to 17 adjacent operations of the same
type can be continuously handled by DMA without CPU intervention. If you
need more than 17 adjacent operations of the same type, the transfer will
reverted to using the byte-by-byte (non-DMA) implementation.</p>
</li>
</ul>
<p>All these limitations also apply to I2C transfers in async mode when using
DMA. They do not apply to I2C transfers in async mode when not using DMA.</p>
<h2 id="async-operation-async"><a class="doc-anchor" href="#async-operation-async">§</a><code>async</code> operation <span class="stab portability" title="Available on crate feature `async` only"><code>async</code></span></h2>
<p>An <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> can be used for <code>async</code> operations. Configuring an <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> in
async mode is relatively simple:</p>
<ul>
<li>Bind the corresponding <code>SERCOM</code> interrupt source to the SPI
<a href="struct.InterruptHandler.html" title="struct atsamd_hal::sercom::i2c::InterruptHandler"><code>InterruptHandler</code></a> (refer to the module-level <a href="../../async_hal/index.html" title="mod atsamd_hal::async_hal"><code>async_hal</code></a>
documentation for more information).</li>
<li>Turn a previously configured <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> into an <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a> by calling
<a href="struct.I2c.html#method.into_future" title="method atsamd_hal::sercom::i2c::I2c::into_future"><code>I2c::into_future</code></a></li>
<li>Optionally, add a DMA channel by using <a href="struct.I2cFuture.html#method.with_dma_channel" title="method atsamd_hal::sercom::i2c::I2cFuture::with_dma_channel"><code>I2cFuture::with_dma_channel</code></a>.
The API is exactly the same whether a DMA channel is used or not.</li>
<li>Use the provided async methods for reading or writing to the I2C
peripheral. <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a> implements <a href="../../../embedded_hal_async/i2c/trait.I2c.html" title="trait embedded_hal_async::i2c::I2c"><code>embedded_hal_async::i2c::I2c</code></a>.</li>
</ul>
<p><code>I2cFuture</code> implements <code>AsRef&lt;I2c&gt;</code> and <code>AsMut&lt;I2c&gt;</code> so that it can be
reconfigured using the regular <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> methods.</p>
<h3 id="considerations-when-using-async-i2c-with-dma-async-dma"><a class="doc-anchor" href="#considerations-when-using-async-i2c-with-dma-async-dma">§</a>Considerations when using <code>async</code> <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> with DMA <span class="stab portability" title="Available on crate feature `async` only"><code>async</code></span> <span class="stab portability" title="Available on crate feature `dma` only"><code>dma</code></span></h3>
<ul>
<li>An <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct must be turned into an <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a> by calling
<a href="struct.I2c.html#method.into_future" title="method atsamd_hal::sercom::i2c::I2c::into_future"><code>I2c::into_future</code></a> before calling <code>with_dma_channel</code>. The DMA channel
itself must also be configured in async mode by using
<a href="../../dmac/dma_controller/struct.DmaController.html#method.into_future" title="method atsamd_hal::dmac::dma_controller::DmaController::into_future"><code>DmaController::into_future</code></a>.
If a DMA channel is added to the <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct before it is turned into
an <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a>, it will not be able to use DMA in async mode.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This will work
</span><span class="kw">let </span>i2c = i2c.into_future().with_dma_channel(channel);

<span class="comment">// This won't
</span><span class="kw">let </span>i2c = i2c.with_dma_channel(channel).into_future();</code></pre></div>
<h4 id="safety-considerations"><a class="doc-anchor" href="#safety-considerations">§</a>Safety considerations</h4>
<p>In <code>async</code> mode, an I2C+DMA transfer does not require <code>'static</code> source and
destination buffers. This, in theory, makes its use <code>unsafe</code>. However it is
marked as safe for better ergonomics, and to enable the implementation of
the <a href="../../../embedded_hal_async/i2c/trait.I2c.html" title="trait embedded_hal_async::i2c::I2c"><code>embedded_hal_async::i2c::I2c</code></a> trait.</p>
<p>This means that, as an user, you <strong>must</strong> ensure that the <a href="https://doc.rust-lang.org/1.87.0/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>s
returned by the <a href="../../../embedded_hal_async/i2c/trait.I2c.html" title="trait embedded_hal_async::i2c::I2c"><code>embedded_hal_async::i2c::I2c</code></a> methods may never be
forgotten through <a href="https://doc.rust-lang.org/1.87.0/core/mem/fn.forget.html" title="fn core::mem::forget"><code>forget</code></a> or by wrapping them with a <a href="https://doc.rust-lang.org/1.87.0/core/mem/manually_drop/struct.ManuallyDrop.html" title="struct core::mem::manually_drop::ManuallyDrop"><code>ManuallyDrop</code></a>.</p>
<p>The returned futures implement <a href="https://doc.rust-lang.org/1.87.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop"><code>Drop</code></a> and will automatically stop any
ongoing transfers; this guarantees that the memory occupied by the
now-dropped buffers may not be corrupted by running transfers.</p>
<p>This means that using functions like <a href="../../../futures_util/macro.select_biased.html" title="macro futures_util::select_biased"><code>futures::select_biased</code></a> to implement
timeouts is safe; transfers will be safely cancelled if the timeout expires.</p>
<p>This also means that should you <a href="https://doc.rust-lang.org/1.87.0/core/mem/fn.forget.html" title="fn core::mem::forget"><code>forget</code></a> this <a href="https://doc.rust-lang.org/1.87.0/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> after its first
<a href="https://doc.rust-lang.org/1.87.0/core/future/future/trait.Future.html#tymethod.poll" title="method core::future::future::Future::poll"><code>poll</code></a> call, the transfer will keep running, ruining the now-reclaimed
memory, as well as the rest of your day.</p>
<ul>
<li><code>await</code>ing is fine: the <a href="https://doc.rust-lang.org/1.87.0/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> will run to completion.</li>
<li>Dropping an incomplete transfer is also fine. Dropping can happen, for
example, if the transfer doesn’t complete before a timeout expires.</li>
<li>Dropping an incomplete transfer <em>without running its destructor</em> is
<strong>unsound</strong> and will trigger undefined behavior.</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>always_ready() {}

<span class="kw">let </span><span class="kw-2">mut </span>buffer = [<span class="number">0x00</span>; <span class="number">10</span>];

<span class="comment">// This is completely safe
</span>i2c.read(<span class="kw-2">&amp;mut </span>buffer).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// This is also safe: we launch a transfer, which is then immediately cancelled
</span><span class="macro">futures::select_biased!</span> {
    <span class="kw">_ </span>= i2c.read(<span class="kw-2">&amp;mut </span>buffer)<span class="question-mark">?</span>,
    <span class="kw">_ </span>= always_ready(),
}

<span class="comment">// This, while contrived, is also safe.
</span>{
    <span class="kw">use </span>core::future::Future;

    <span class="kw">let </span>future = i2c.read(<span class="kw-2">&amp;mut </span>buffer);
    <span class="macro">futures::pin_mut!</span>(future);
    <span class="comment">// Assume ctx is a `core::task::Context` given out by the executor.
    // The future is polled, therefore starting the transfer
    </span>future.as_mut().poll(ctx);

    <span class="comment">// Future is dropped here - transfer is cancelled.
</span>}

<span class="comment">// DANGER: This is an example of undefined behavior
</span>{
    <span class="kw">use </span>core::future::Future;
    <span class="kw">use </span>core::ops::DerefMut;

    <span class="kw">let </span>future = core::mem::ManuallyDrop::new(i2c.read(<span class="kw-2">&amp;mut </span>buffer));
    <span class="macro">futures::pin_mut!</span>(future);
    <span class="comment">// To actually make this example compile, we would need to wrap the returned
    // future from `i2c.read()` in a newtype that implements Future, because we
    // can't actually call as_mut() without being able to name the type we want
    // to deref to.
    </span><span class="kw">let </span>future_ref: <span class="kw-2">&amp;mut </span>SomeNewTypeFuture = <span class="kw-2">&amp;mut </span>future.as_mut();
    future.as_mut().poll(ctx);

    <span class="comment">// Future is NOT dropped here - transfer is not cancelled, resulting un UB.
</span>}</code></pre></div>
<p>As you can see, unsoundness is relatively hard to come by - however, caution
should still be exercised.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config">Config</a></dt><dd>A configurable, disabled I2C peripheral</dd><dt><a class="struct" href="struct.Flags.html" title="struct atsamd_hal::sercom::i2c::Flags">Flags</a></dt><dd>Interrupt bitflags for I2C transactions</dd><dt><a class="struct" href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c">I2c</a></dt><dd>Abstraction over a I2C peripheral, allowing to perform I2C transactions.</dd><dt><a class="struct" href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture">I2cFuture</a></dt><dd><code>async</code> version of <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a>.</dd><dt><a class="struct" href="struct.InterruptHandler.html" title="struct atsamd_hal::sercom::i2c::InterruptHandler">Interrupt<wbr>Handler</a></dt><dd>Interrupt handler for async I2C operarions</dd><dt><a class="struct" href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads">Pads</a></dt><dd>Container for a set of SERCOM <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a>s</dd><dt><a class="struct" href="struct.Status.html" title="struct atsamd_hal::sercom::i2c::Status">Status</a></dt><dd>Status flags for I2C transactions</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.BusState.html" title="enum atsamd_hal::sercom::i2c::BusState">BusState</a></dt><dd>Type representing the current bus state</dd><dt><a class="enum" href="enum.Error.html" title="enum atsamd_hal::sercom::i2c::Error">Error</a></dt><dd>Errors available for I2C transactions</dd><dt><a class="enum" href="enum.InactiveTimeout.html" title="enum atsamd_hal::sercom::i2c::InactiveTimeout">Inactive<wbr>Timeout</a></dt><dd>Inactive timeout configuration</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.AnyConfig.html" title="trait atsamd_hal::sercom::i2c::AnyConfig">AnyConfig</a></dt><dd>Type class for all possible <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> types</dd><dt><a class="trait" href="trait.PadSet.html" title="trait atsamd_hal::sercom::i2c::PadSet">PadSet</a></dt><dd>Type-level function to recover the <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a> types from a generic set
of <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a></dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.ConfigSercom.html" title="type atsamd_hal::sercom::i2c::ConfigSercom">Config<wbr>Sercom</a></dt><dd>Type alias to recover the specific <a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a> type from an implementation of
<a href="trait.AnyConfig.html" title="trait atsamd_hal::sercom::i2c::AnyConfig"><code>AnyConfig</code></a></dd><dt><a class="type" href="type.I2cFutureDma.html" title="type atsamd_hal::sercom::i2c::I2cFutureDma">I2cFuture<wbr>Dma</a></dt><dd>Convenience type for a <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a> in DMA mode.</dd><dt><a class="type" href="type.PadsFromIds.html" title="type atsamd_hal::sercom::i2c::PadsFromIds">Pads<wbr>From<wbr>Ids</a></dt><dd>Define a set of <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> using <a href="../../gpio/pin/trait.PinId.html" title="trait atsamd_hal::gpio::pin::PinId"><code>PinId</code></a>s instead of <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s</dd><dt><a class="type" href="type.SpecificConfig.html" title="type atsamd_hal::sercom::i2c::SpecificConfig">Specific<wbr>Config</a></dt><dd>Type alias to recover the specific <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> type from an implementation of
<a href="trait.AnyConfig.html" title="trait atsamd_hal::sercom::i2c::AnyConfig"><code>AnyConfig</code></a></dd><dt><a class="type" href="type.Word.html" title="type atsamd_hal::sercom::i2c::Word">Word</a></dt><dd>Word size for an I2C message</dd></dl></section></div></main></body></html>