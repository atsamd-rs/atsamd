<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="USB composite device."><title>usb_device::device - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="usb_device" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-3a5871a4.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../usb_device/index.html">usb_<wbr>device</a><span class="version">0.3.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module device</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate usb_<wbr>device</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">usb_device</a></div><h1>Module <span>device</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/usb_device/device.rs.html#1-686">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>USB composite device.</p>
<p>The <a href="struct.UsbDevice.html" title="struct usb_device::device::UsbDevice">UsbDevice</a> type in this module is the core of this crate. It combines
multiple USB class implementations and the USB bus driver and dispatches bus state changes and
control messages between them.</p>
<p>To implement USB support for your own project, the required code is usually as follows:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>usb_device::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>usb_serial; <span class="comment">// example class crate (not included)

// Create the device-specific USB peripheral driver. The exact name and arguments are device
// specific, so check the documentation for your device driver crate.
</span><span class="kw">let </span>usb_bus = device_specific_usb::UsbBus::new(...);

<span class="comment">// Create one or more USB class implementation. The name and arguments depend on the class,
// however most classes require the UsbAllocator as the first argument in order to allocate
// the required shared resources.
</span><span class="kw">let </span><span class="kw-2">mut </span>serial = usb_serial::SerialPort::new(<span class="kw-2">&amp;</span>usb_bus.allocator());

<span class="comment">// Build the final [UsbDevice](device::UsbDevice) instance. The required arguments are a
// reference to the peripheral driver created earlier, as well as a USB vendor ID/product ID
// pair. Additional builder arguments can specify parameters such as device class code or
// product name. If using an existing class, remember to check the class crate documentation
// for correct values.
</span><span class="kw">let </span><span class="kw-2">mut </span>usb_dev = UsbDeviceBuilder::new(<span class="kw-2">&amp;</span>usb_bus, UsbVidPid(<span class="number">0x5824</span>, <span class="number">0x27dd</span>))
    .strings(<span class="kw-2">&amp;</span>[StringDescriptors::new(LangID::EN)
        .product(<span class="string">"Serial port"</span>)])
        .expect(<span class="string">"Failed to set strings"</span>)
    .device_class(usb_serial::DEVICE_CLASS)
    .build();

<span class="comment">// At this point the USB peripheral is enabled and a connected host will attempt to enumerate
// it.
</span><span class="kw">loop </span>{
    <span class="comment">// Must be called more often than once every 10ms to handle events and stay USB compilant,
    // or from a device-specific interrupt handler.
    </span><span class="kw">if </span>(usb_dev.poll(<span class="kw-2">&amp;mut </span>[<span class="kw-2">&amp;mut </span>serial])) {
        <span class="comment">// Call class-specific methods here
        </span>serial.read(...);
    }
}</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.StringDescriptors.html" title="struct usb_device::device::StringDescriptors">String<wbr>Descriptors</a></dt><dd>Provides basic string descriptors about the device, including the manufacturer, product name,
and serial number of the device in a specified language.</dd><dt><a class="struct" href="struct.UsbDevice.html" title="struct usb_device::device::UsbDevice">UsbDevice</a></dt><dd>A USB device consisting of one or more device classes.</dd><dt><a class="struct" href="struct.UsbDeviceBuilder.html" title="struct usb_device::device::UsbDeviceBuilder">UsbDevice<wbr>Builder</a></dt><dd>Used to build new <a href="struct.UsbDevice.html" title="struct usb_device::device::UsbDevice"><code>UsbDevice</code></a>s.</dd><dt><a class="struct" href="struct.UsbVidPid.html" title="struct usb_device::device::UsbVidPid">UsbVid<wbr>Pid</a></dt><dd>A USB vendor ID and product ID pair.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.UsbDeviceState.html" title="enum usb_device::device::UsbDeviceState">UsbDevice<wbr>State</a></dt><dd>The global state of the USB device.</dd><dt><a class="enum" href="enum.UsbRev.html" title="enum usb_device::device::UsbRev">UsbRev</a></dt><dd>Usb spec revision.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.CONFIGURATION_NONE.html" title="constant usb_device::device::CONFIGURATION_NONE">CONFIGURATION_<wbr>NONE</a></dt><dd>The bConfiguration value for the not configured state.</dd><dt><a class="constant" href="constant.CONFIGURATION_VALUE.html" title="constant usb_device::device::CONFIGURATION_VALUE">CONFIGURATION_<wbr>VALUE</a></dt><dd>The bConfiguration value for the single configuration supported by this device.</dd><dt><a class="constant" href="constant.DEFAULT_ALTERNATE_SETTING.html" title="constant usb_device::device::DEFAULT_ALTERNATE_SETTING">DEFAULT_<wbr>ALTERNATE_<wbr>SETTING</a></dt><dd>The default value for bAlternateSetting for all interfaces.</dd></dl></section></div></main></body></html>