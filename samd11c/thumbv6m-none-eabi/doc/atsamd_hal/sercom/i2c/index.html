<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Use the SERCOM peripheral for I2C communications"><title>atsamd_hal::sercom::i2c - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="atsamd_hal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../atsamd_hal/index.html">atsamd_<wbr>hal</a><span class="version">0.21.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module i2c</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#pads" title="`Pads`"><code>Pads</code></a></li><li><a href="#config" title="`Config`"><code>Config</code></a><ul><li><a href="#reading-the-current-configuration" title="Reading the current configuration">Reading the current configuration</a></li></ul></li><li><a href="#i2c" title="`I2c`"><code>I2c</code></a></li><li><a href="#reading-the-current-configuration-1" title="Reading the current configuration">Reading the current configuration</a></li><li><a href="#reconfiguring" title="Reconfiguring">Reconfiguring</a></li><li><a href="#non-supported-features" title="Non-supported features">Non-supported features</a></li><li><a href="#using-i2c-with-dma-dma" title="Using I2C with DMA dma">Using I2C with DMA dma</a><ul><li><a href="#limitations-of-using-dma-with-i2c" title="Limitations of using DMA with I2C">Limitations of using DMA with I2C</a></li></ul></li><li><a href="#async-operation-async" title="`async` operation async"><code>async</code> operation async</a><ul><li><a href="#considerations-when-using-async-i2c-with-dma-async-dma" title="Considerations when using `async` `I2c` with DMA async dma">Considerations when using <code>async</code> <code>I2c</code> with DMA async dma</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In atsamd_<wbr>hal::<wbr>sercom</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">atsamd_hal</a>::<wbr><a href="../index.html">sercom</a></span><h1>Module <span>i2c</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/atsamd_hal/sercom/i2c.rs.html#1-597">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Use the SERCOM peripheral for I2C communications</p>
<p>Configuring an I2C peripheral occurs in three steps. First, you must create
a set of <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> for use by the peripheral. Next, you assemble pieces into
a <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> struct. After configuring the peripheral, you then <a href="struct.Config.html#method.enable" title="method atsamd_hal::sercom::i2c::Config::enable"><code>enable</code></a>
it, yielding a functional <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct.
Transactions are performed using the <a href="embedded_hal::blocking::i2c"><code>i2c</code></a>
traits from embedded HAL.</p>
<h2 id="pads"><a class="doc-anchor" href="#pads">§</a><a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a></h2>
<p>A <a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a> uses two <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s as peripheral <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a>s, but only
certain <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a> combinations are acceptable. In particular, all <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s
must be mapped to the same <a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a>, and SDA is always <a href="../pad/enum.Pad0.html" title="enum atsamd_hal::sercom::pad::Pad0"><code>Pad0</code></a>, while SCL
is always <a href="../pad/enum.Pad1.html" title="enum atsamd_hal::sercom::pad::Pad1"><code>Pad1</code></a> (see the datasheet). This HAL makes it impossible to use
invalid <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>/<a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a> combinations, and the <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> struct is responsible
for enforcing these constraints.</p>
<p>A <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> type takes three or four type parameters, depending on the chip.
The first type always specifies the <a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a>. On SAMx5x chips, the second
type specifies the <code>IoSet</code>. The remaining two, <code>SDA</code> and <code>SCL</code> represent the
SDA and SCL pads respectively. A <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a> is just a <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a> configured in the
correct <a href="../../gpio/pin/trait.PinMode.html" title="trait atsamd_hal::gpio::pin::PinMode"><code>PinMode</code></a> that implements <a href="../pad/trait.IsPad.html" title="trait atsamd_hal::sercom::pad::IsPad"><code>IsPad</code></a>. The
<a href="../../macro.bsp_pins.html" title="macro atsamd_hal::bsp_pins"><code>bsp_pins!</code></a> macro can be used to define convenient type
aliases for <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a> types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::gpio::{PA08, PA09, AlternateC};
<span class="kw">use </span>atsamd_hal::sercom::{Sercom0, i2c};
<span class="kw">use </span>atsamd_hal::typelevel::NoneT;

<span class="comment">// SAMx5x-specific imports
</span><span class="kw">use </span>atsamd_hal::sercom::pad::IoSet1;

<span class="kw">type </span>Sda = Pin&lt;PA08, AlternateC&gt;;
<span class="kw">type </span>Scl = Pin&lt;PA09, AlternateC&gt;;

<span class="comment">// SAMD11/SAMD21 version
</span><span class="kw">type </span>Pads = i2c::Pads&lt;Sercom0, Sda, Scl&gt;;
<span class="comment">// SAMx5x version
</span><span class="kw">type </span>Pads = i2c::Pads&lt;Sercom0, IoSet1, Sda, Scl&gt;;</code></pre></div>
<p>Alternatively, you can use the <a href="type.PadsFromIds.html" title="type atsamd_hal::sercom::i2c::PadsFromIds"><code>PadsFromIds</code></a> alias to define a set of
<code>Pads</code> in terms of <a href="../../gpio/pin/trait.PinId.html" title="trait atsamd_hal::gpio::pin::PinId"><code>PinId</code></a>s instead of <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s. This is useful when you
don’t have <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a> aliases pre-defined.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::gpio::{PA08, PA09};
<span class="kw">use </span>atsamd_hal::sercom::{Sercom0, i2c};

<span class="kw">type </span>Pads = i2c::PadsFromIds&lt;Sercom0, PA08, PA09&gt;;</code></pre></div>
<p>Instances of <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> are created using the <a href="struct.Pads.html#method.new" title="associated function atsamd_hal::sercom::i2c::Pads::new"><code>new</code></a> method.</p>
<p>On SAMD21 and SAMx5x chips, <a href="struct.Pads.html#method.new" title="associated function atsamd_hal::sercom::i2c::Pads::new"><code>new</code></a> method automatically convert
each pin to the correct <a href="../../gpio/pin/trait.PinMode.html" title="trait atsamd_hal::gpio::pin::PinMode"><code>PinMode</code></a>. But for SAMD11 chips, users must
manually convert each pin before calling the builder methods. This is a
consequence of inherent ambiguities in the SAMD11 SERCOM pad definitions.
Specifically, the same <a href="../../gpio/pin/trait.PinId.html" title="trait atsamd_hal::gpio::pin::PinId"><code>PinId</code></a> can correspond to two different <a href="../pad/trait.PadNum.html" title="trait atsamd_hal::sercom::pad::PadNum"><code>PadNum</code></a>s
for the <em>same</em> <code>Sercom</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::pac::Peripherals;
<span class="kw">use </span>atsamd_hal::gpio::Pins;
<span class="kw">use </span>atsamd_hal::sercom::{Sercom0, i2c};

<span class="kw">let </span><span class="kw-2">mut </span>peripherals = Peripherals::take().unwrap();
<span class="kw">let </span>pins = Pins::new(peripherals.PORT);
<span class="kw">let </span>pads = i2c::Pads::&lt;Sercom0&gt;::new(pins.pa08, pins.pa09);</code></pre></div>
<h2 id="config"><a class="doc-anchor" href="#config">§</a><a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a></h2>
<p>Next, create a <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> struct, which represents the I2C peripheral in
its disabled state. A <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> is specified with one type parameters, the
<a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> type.</p>
<p>Upon creation, the <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> takes ownership of both the <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> struct
and the PAC <a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a> struct. It takes a reference to the PM, so that it
can enable the APB clock, and it takes a frequency to indicate the GCLK
configuration. Users are responsible for correctly configuring the GCLK.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::gpio::{PA08, PA09};
<span class="kw">use </span>atsamd_hal::sercom::{Sercom0, i2c};

<span class="kw">type </span>Pads = i2c::PadsFromIds&lt;Sercom0, PA08, PA09&gt;;
<span class="kw">type </span>Config = i2c::Config&lt;Pads&gt;;

<span class="kw">let </span>pm = peripherals.PM;
<span class="kw">let </span>sercom = peripherals.SERCOM0;
<span class="comment">// Configure GCLK for 10 MHz
</span><span class="kw">let </span>freq = <span class="number">10</span>.mhz();
<span class="kw">let </span>config = i2c::Config::new(<span class="kw-2">&amp;</span>pm, sercom, pads, freq);</code></pre></div>
<p>The <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> struct can configure the peripheral in one of two ways:</p>
<ul>
<li>A set of methods is provided to use in a builder pattern: for example
<a href="struct.Config.html#method.baud" title="method atsamd_hal::sercom::i2c::Config::baud"><code>baud</code></a>, <a href="struct.Config.html#method.run_in_standby" title="method atsamd_hal::sercom::i2c::Config::run_in_standby"><code>run_in_standby</code></a>, etc.
These methods take <code>self</code> and return <code>Self</code>.</li>
<li>A set of methods is provided to use as setters: for example
<a href="struct.Config.html#method.set_baud" title="method atsamd_hal::sercom::i2c::Config::set_baud"><code>set_baud</code></a>,
<a href="struct.Config.html#method.set_run_in_standby" title="method atsamd_hal::sercom::i2c::Config::set_run_in_standby"><code>set_run_in_standby</code></a>, etc. These methods
take <code>&amp;mut self</code> and return nothing.</li>
</ul>
<p>In any case, the peripheral setup ends with a call to <a href="struct.Config.html#method.enable" title="method atsamd_hal::sercom::i2c::Config::enable"><code>enable</code></a>, which
consumes the <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> and returns an enabled <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> peripheral.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>i2c = i2c::Config::new(<span class="kw-2">&amp;</span>pm, sercom, pads, freq)
    .baud(<span class="number">1</span>.mhz())
    .enable();</code></pre></div>
<p>Alternatively,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>i2c = i2c::Config::new(<span class="kw-2">&amp;</span>mclk, sercom, pads, freq);
    i2c.set_baud(<span class="number">1</span>.mhz());
    <span class="kw">let </span>i2c = i2c.enable();</code></pre></div>
<h3 id="reading-the-current-configuration"><a class="doc-anchor" href="#reading-the-current-configuration">§</a>Reading the current configuration</h3>
<p>It is possible to read the current configuration by using the getter methods
provided: for example <a href="struct.Config.html#method.get_baud" title="method atsamd_hal::sercom::i2c::Config::get_baud"><code>get_baud</code></a>,
<a href="struct.Config.html#method.get_run_in_standby" title="method atsamd_hal::sercom::i2c::Config::get_run_in_standby"><code>get_run_in_standby</code></a>, etc.</p>
<h2 id="i2c"><a class="doc-anchor" href="#i2c">§</a><a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a></h2>
<p><a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> structs can only be created from a <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a>. They have one type
parameter, representing the underlying <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a>.</p>
<p>Only the <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct can actually perform
transactions. To do so, use the <a href="../../../embedded_hal/i2c/trait.I2c.html" title="trait embedded_hal::i2c::I2c"><code>embedded_hal::i2c::I2c</code></a> trait.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>embedded_hal::i2c::I2c;

i2c.write(<span class="number">0x54</span>, <span class="number">0x0fe</span>).unwrap();</code></pre></div>
<h2 id="reading-the-current-configuration-1"><a class="doc-anchor" href="#reading-the-current-configuration-1">§</a>Reading the current configuration</h2>
<p>The <code>AsRef&lt;Config&lt;P&gt;&gt;</code> trait is implemented for <code>I2c&lt;Config&lt;P&gt;&gt;</code>.
This means you can use the <code>get_</code> methods implemented for <code>Config</code>, since
they take an <code>&amp;self</code> argument.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Assume i2c is a I2c&lt;C&lt;P&gt;&gt;
</span><span class="kw">let </span>baud = i2c.as_ref().get_baud();</code></pre></div>
<h2 id="reconfiguring"><a class="doc-anchor" href="#reconfiguring">§</a>Reconfiguring</h2>
<p>The <a href="struct.I2c.html#method.reconfigure" title="method atsamd_hal::sercom::i2c::I2c::reconfigure"><code>reconfigure</code></a> method gives out an <code>&amp;mut Config</code> reference, which can
then use the <code>set_*</code> methods.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::sercom::i2c::I2c;

<span class="comment">// Assume config is a valid Duplex I2C Config struct
</span><span class="kw">let </span>i2c = config.enable();

<span class="comment">// Send/receive data...

// Reconfigure I2C peripheral
</span>i2c.reconfigure(|c| c.set_run_in_standby(<span class="bool-val">false</span>));

<span class="comment">// Disable I2C peripheral
</span><span class="kw">let </span>config = i2c.disable();</code></pre></div>
<h2 id="non-supported-features"><a class="doc-anchor" href="#non-supported-features">§</a>Non-supported features</h2>
<ul>
<li>Slave mode is not supported at this time.</li>
<li>High-speed mode is not supported.</li>
<li>4-wire mode is not supported.</li>
<li>32-bit extension mode is not supported (SAMx5x). If you need to transfer
slices, consider using the DMA methods instead <span class="stab
portability" title="Available on crate feature `dma`
only"><code>dma</code></span>.</li>
</ul>
<h2 id="using-i2c-with-dma-dma"><a class="doc-anchor" href="#using-i2c-with-dma-dma">§</a>Using I2C with DMA <span class="stab portability" title="Available on crate feature `dma` only"><code>dma</code></span></h2>
<p>This HAL includes support for DMA-enabled I2C transfers. Use
<a href="struct.I2c.html#method.with_dma_channel" title="method atsamd_hal::sercom::i2c::I2c::with_dma_channel"><code>I2c::with_dma_channel</code></a> to attach a DMA channel to the <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct. A
DMA-enabled <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> implements the blocking
<a href="../../../embedded_hal/i2c/trait.I2c.html" title="trait embedded_hal::i2c::I2c"><code>embedded_hal::i2c::I2c</code></a> trait, which can be used
to perform I2C transfers which are fast, continuous and low jitter, even
if they are preemped by a higher priority interrupt.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>atsamd_hal::dmac::channel::{AnyChannel, Ready};
<span class="kw">use </span>atsand_hal::sercom::i2c::{I2c, AnyConfig, Error};
<span class="kw">use </span>atsamd_hal::embedded_hal::i2c::I2c;
<span class="kw">fn </span>i2c_write_with_dma&lt;A: AnyConfig, C: AnyChannel&lt;Status = Ready&gt;&gt;(i2c: I2c&lt;A&gt;, channel: C, bytes: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), Error&gt;{
    <span class="comment">// Attach a DMA channel
    </span><span class="kw">let </span>i2c = i2c.with_dma_channel(channel);
    i2c.write(<span class="number">0x54</span>, bytes)<span class="question-mark">?</span>;
}</code></pre></div>
<h3 id="limitations-of-using-dma-with-i2c"><a class="doc-anchor" href="#limitations-of-using-dma-with-i2c">§</a>Limitations of using DMA with I2C</h3>
<ul>
<li>
<p>The I2C peripheral only supports continuous DMA read/writes of up to 255
bytes. Trying to read/write with a transfer of 256 bytes or more will
result in a panic. This also applies to using <a href="../../../embedded_hal/i2c/trait.I2c.html#tymethod.transaction" title="method embedded_hal::i2c::I2c::transaction"><code>I2c::transaction</code></a> with
adjacent write/read operations of the same type; the total number of bytes
across all adjacent operations must not exceed 256. If you need continuous
transfers of 256 bytes or more, use the non-DMA <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> implementations.</p>
</li>
<li>
<p>When using <a href="../../../embedded_hal/i2c/trait.I2c.html#tymethod.transaction" title="method embedded_hal::i2c::I2c::transaction"><code>I2c::transaction</code></a> or <a href="../../../embedded_hal/i2c/trait.I2c.html#method.write_read" title="method embedded_hal::i2c::I2c::write_read"><code>I2c::write_read</code></a>, the
<a href="../../../embedded_hal/i2c/trait.I2c.html" title="trait embedded_hal::i2c::I2c"><code>embedded_hal::i2c::I2c</code></a> specification mandates that a REPEATED START
(instead of a STOP+START) is sent between transactions of a different type
(read/write). Unfortunately, in DMA mode, the hardware is only capable of
sending STOP+START. If you absolutely need repeated starts, the only
workaround is to use the I2C without DMA.</p>
</li>
<li>
<p>Using <a href="../../../embedded_hal/i2c/trait.I2c.html#tymethod.transaction" title="method embedded_hal::i2c::I2c::transaction"><code>I2c::transaction</code></a> consumes significantly more memory than the
other methods provided by <a href="../../../embedded_hal/i2c/trait.I2c.html" title="trait embedded_hal::i2c::I2c"><code>embedded_hal::i2c::I2c</code></a> (at least 256 bytes
extra).</p>
</li>
<li>
<p>When using <a href="../../../embedded_hal/i2c/trait.I2c.html#tymethod.transaction" title="method embedded_hal::i2c::I2c::transaction"><code>I2c::transaction</code></a>, up to 17 adjacent operations of the same
type can be continuously handled by DMA without CPU intervention. If you
need more than 17 adjacent operations of the same type, the transfer will
reverted to using the byte-by-byte (non-DMA) implementation.</p>
</li>
</ul>
<p>All these limitations also apply to I2C transfers in async mode when using
DMA. They do not apply to I2C transfers in async mode when not using DMA.</p>
<h2 id="async-operation-async"><a class="doc-anchor" href="#async-operation-async">§</a><code>async</code> operation <span class="stab portability" title="Available on crate feature `async` only"><code>async</code></span></h2>
<p>An <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> can be used for
<code>async</code> operations. Configuring an <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> in async mode is relatively
simple:</p>
<ul>
<li>Bind the corresponding <code>SERCOM</code> interrupt source to the SPI
<a href="struct.InterruptHandler.html" title="struct atsamd_hal::sercom::i2c::InterruptHandler"><code>InterruptHandler</code></a> (refer to the module-level <a href="../../async_hal/index.html" title="mod atsamd_hal::async_hal"><code>async_hal</code></a>
documentation for more information).</li>
<li>Turn a previously configured <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> into an <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a> by calling
<a href="struct.I2c.html#method.into_future" title="method atsamd_hal::sercom::i2c::I2c::into_future"><code>I2c::into_future</code></a></li>
<li>Optionally, add a DMA channel by using <a href="struct.I2cFuture.html#method.with_dma_channel" title="method atsamd_hal::sercom::i2c::I2cFuture::with_dma_channel"><code>I2cFuture::with_dma_channel</code></a>.
The API is exactly the same whether a DMA channel is used or not.</li>
<li>Use the provided async methods for reading or writing to the I2C
peripheral. <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a> implements <a href="../../../embedded_hal_async/i2c/trait.I2c.html" title="trait embedded_hal_async::i2c::I2c"><code>embedded_hal_async::i2c::I2c</code></a>.</li>
</ul>
<p><code>I2cFuture</code> implements <code>AsRef&lt;I2c&gt;</code> and <code>AsMut&lt;I2c&gt;</code> so
that it can be reconfigured using the regular <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> methods.</p>
<h3 id="considerations-when-using-async-i2c-with-dma-async-dma"><a class="doc-anchor" href="#considerations-when-using-async-i2c-with-dma-async-dma">§</a>Considerations when using <code>async</code> <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> with DMA <span class="stab portability" title="Available on crate feature `async` only"><code>async</code></span> <span class="stab portability" title="Available on crate feature `dma` only"><code>dma</code></span></h3>
<ul>
<li>An <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct must be turned into an <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a> by calling
<a href="struct.I2c.html#method.into_future" title="method atsamd_hal::sercom::i2c::I2c::into_future"><code>I2c::into_future</code></a> before calling <code>with_dma_channel</code>. The DMA channel
itself must also be configured in async mode by using
<a href="../../dmac/dma_controller/struct.DmaController.html#method.into_future" title="method atsamd_hal::dmac::dma_controller::DmaController::into_future"><code>DmaController::into_future</code></a>.
If a DMA channel is added to the <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a> struct before it is turned into
an <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a>, it will not be able to use DMA in async mode.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This will work
</span><span class="kw">let </span>i2c = i2c.into_future().with_dma_channel(channel);

<span class="comment">// This won't
</span><span class="kw">let </span>i2c = i2c.with_dma_channel(channel).into_future();</code></pre></div>
<h4 id="safety-considerations"><a class="doc-anchor" href="#safety-considerations">§</a>Safety considerations</h4>
<p>In <code>async</code> mode, an I2C+DMA transfer does not require <code>'static</code> source and
destination buffers. This, in theory, makes its use <code>unsafe</code>. However it is
marked as safe for better ergonomics, and to enable the implementation of
the <a href="../../../embedded_hal_async/i2c/trait.I2c.html" title="trait embedded_hal_async::i2c::I2c"><code>embedded_hal_async::i2c::I2c</code></a> trait.</p>
<p>This means that, as an user, you <strong>must</strong> ensure that the <a href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>s
returned by the <a href="../../../embedded_hal_async/i2c/trait.I2c.html" title="trait embedded_hal_async::i2c::I2c"><code>embedded_hal_async::i2c::I2c</code></a> methods may never be
forgotten through <a href="https://doc.rust-lang.org/1.85.0/core/mem/fn.forget.html" title="fn core::mem::forget"><code>forget</code></a> or by wrapping them with a <a href="https://doc.rust-lang.org/1.85.0/core/mem/manually_drop/struct.ManuallyDrop.html" title="struct core::mem::manually_drop::ManuallyDrop"><code>ManuallyDrop</code></a>.</p>
<p>The returned futures implement <a href="https://doc.rust-lang.org/1.85.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop"><code>Drop</code></a> and will automatically stop any
ongoing transfers; this guarantees that the memory occupied by the
now-dropped buffers may not be corrupted by running transfers.</p>
<p>This means that using functions like <a href="../../../futures_util/macro.select_biased.html" title="macro futures_util::select_biased"><code>futures::select_biased</code></a> to implement
timeouts is safe; transfers will be safely cancelled if the timeout expires.</p>
<p>This also means that should you <a href="https://doc.rust-lang.org/1.85.0/core/mem/fn.forget.html" title="fn core::mem::forget"><code>forget</code></a> this <a href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> after its
first <a href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html#tymethod.poll" title="method core::future::future::Future::poll"><code>poll</code></a> call, the transfer will keep running, ruining the
now-reclaimed memory, as well as the rest of your day.</p>
<ul>
<li><code>await</code>ing is fine: the <a href="https://doc.rust-lang.org/1.85.0/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> will run to completion.</li>
<li>Dropping an incomplete transfer is also fine. Dropping can happen, for
example, if the transfer doesn’t complete before a timeout expires.</li>
<li>Dropping an incomplete transfer <em>without running its destructor</em> is
<strong>unsound</strong> and will trigger undefined behavior.</li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>always_ready() {}

<span class="kw">let </span><span class="kw-2">mut </span>buffer = [<span class="number">0x00</span>; <span class="number">10</span>];

<span class="comment">// This is completely safe
</span>i2c.read(<span class="kw-2">&amp;mut </span>buffer).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// This is also safe: we launch a transfer, which is then immediately cancelled
</span><span class="macro">futures::select_biased!</span> {
    <span class="kw">_ </span>= i2c.read(<span class="kw-2">&amp;mut </span>buffer)<span class="question-mark">?</span>,
    <span class="kw">_ </span>= always_ready(),
}

<span class="comment">// This, while contrived, is also safe.
</span>{
    <span class="kw">use </span>core::future::Future;

    <span class="kw">let </span>future = i2c.read(<span class="kw-2">&amp;mut </span>buffer);
    <span class="macro">futures::pin_mut!</span>(future);
    <span class="comment">// Assume ctx is a `core::task::Context` given out by the executor.
    // The future is polled, therefore starting the transfer
    </span>future.as_mut().poll(ctx);

    <span class="comment">// Future is dropped here - transfer is cancelled.
</span>}

<span class="comment">// DANGER: This is an example of undefined behavior
</span>{
    <span class="kw">use </span>core::future::Future;
    <span class="kw">use </span>core::ops::DerefMut;

    <span class="kw">let </span>future = core::mem::ManuallyDrop::new(i2c.read(<span class="kw-2">&amp;mut </span>buffer));
    <span class="macro">futures::pin_mut!</span>(future);
    <span class="comment">// To actually make this example compile, we would need to wrap the returned
    // future from `i2c.read()` in a newtype that implements Future, because we
    // can't actually call as_mut() without being able to name the type we want
    // to deref to.
    </span><span class="kw">let </span>future_ref: <span class="kw-2">&amp;mut </span>SomeNewTypeFuture = <span class="kw-2">&amp;mut </span>future.as_mut();
    future.as_mut().poll(ctx);

    <span class="comment">// Future is NOT dropped here - transfer is not cancelled, resulting un UB.
</span>}</code></pre></div>
<p>As you can see, unsoundness is relatively hard to come by - however, caution
should still be exercised.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config">Config</a></div><div class="desc docblock-short">A configurable, disabled I2C peripheral</div></li><li><div class="item-name"><a class="struct" href="struct.Flags.html" title="struct atsamd_hal::sercom::i2c::Flags">Flags</a></div><div class="desc docblock-short">Interrupt bitflags for I2C transactions</div></li><li><div class="item-name"><a class="struct" href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c">I2c</a></div><div class="desc docblock-short">Abstraction over a I2C peripheral, allowing to perform I2C transactions.</div></li><li><div class="item-name"><a class="struct" href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture">I2cFuture</a></div><div class="desc docblock-short"><code>async</code> version of <a href="struct.I2c.html" title="struct atsamd_hal::sercom::i2c::I2c"><code>I2c</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.InterruptHandler.html" title="struct atsamd_hal::sercom::i2c::InterruptHandler">Interrupt<wbr>Handler</a></div><div class="desc docblock-short">Interrupt handler for async I2C operarions</div></li><li><div class="item-name"><a class="struct" href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads">Pads</a></div><div class="desc docblock-short">Container for a set of SERCOM <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a>s</div></li><li><div class="item-name"><a class="struct" href="struct.Status.html" title="struct atsamd_hal::sercom::i2c::Status">Status</a></div><div class="desc docblock-short">Status flags for I2C transactions</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.BusState.html" title="enum atsamd_hal::sercom::i2c::BusState">BusState</a></div><div class="desc docblock-short">Type representing the current bus state</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum atsamd_hal::sercom::i2c::Error">Error</a></div><div class="desc docblock-short">Errors available for I2C transactions</div></li><li><div class="item-name"><a class="enum" href="enum.InactiveTimeout.html" title="enum atsamd_hal::sercom::i2c::InactiveTimeout">Inactive<wbr>Timeout</a></div><div class="desc docblock-short">Inactive timeout configuration</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AnyConfig.html" title="trait atsamd_hal::sercom::i2c::AnyConfig">AnyConfig</a></div><div class="desc docblock-short">Type class for all possible <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> types</div></li><li><div class="item-name"><a class="trait" href="trait.PadSet.html" title="trait atsamd_hal::sercom::i2c::PadSet">PadSet</a></div><div class="desc docblock-short">Type-level function to recover the <a href="../pad/type.Pad.html" title="type atsamd_hal::sercom::pad::Pad"><code>Pad</code></a> types from a generic set
of <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a></div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ConfigSercom.html" title="type atsamd_hal::sercom::i2c::ConfigSercom">Config<wbr>Sercom</a></div><div class="desc docblock-short">Type alias to recover the specific <a href="../trait.Sercom.html" title="trait atsamd_hal::sercom::Sercom"><code>Sercom</code></a> type from an implementation of
<a href="trait.AnyConfig.html" title="trait atsamd_hal::sercom::i2c::AnyConfig"><code>AnyConfig</code></a></div></li><li><div class="item-name"><a class="type" href="type.I2cFutureDma.html" title="type atsamd_hal::sercom::i2c::I2cFutureDma">I2cFuture<wbr>Dma</a></div><div class="desc docblock-short">Convenience type for a <a href="struct.I2cFuture.html" title="struct atsamd_hal::sercom::i2c::I2cFuture"><code>I2cFuture</code></a> in DMA mode.</div></li><li><div class="item-name"><a class="type" href="type.PadsFromIds.html" title="type atsamd_hal::sercom::i2c::PadsFromIds">Pads<wbr>From<wbr>Ids</a></div><div class="desc docblock-short">Define a set of <a href="struct.Pads.html" title="struct atsamd_hal::sercom::i2c::Pads"><code>Pads</code></a> using <a href="../../gpio/pin/trait.PinId.html" title="trait atsamd_hal::gpio::pin::PinId"><code>PinId</code></a>s instead of <a href="../../gpio/pin/struct.Pin.html" title="struct atsamd_hal::gpio::pin::Pin"><code>Pin</code></a>s</div></li><li><div class="item-name"><a class="type" href="type.SpecificConfig.html" title="type atsamd_hal::sercom::i2c::SpecificConfig">Specific<wbr>Config</a></div><div class="desc docblock-short">Type alias to recover the specific <a href="struct.Config.html" title="struct atsamd_hal::sercom::i2c::Config"><code>Config</code></a> type from an implementation of
<a href="trait.AnyConfig.html" title="trait atsamd_hal::sercom::i2c::AnyConfig"><code>AnyConfig</code></a></div></li><li><div class="item-name"><a class="type" href="type.Word.html" title="type atsamd_hal::sercom::i2c::Word">Word</a></div><div class="desc docblock-short">Word size for an I2C message</div></li></ul></section></div></main></body></html>