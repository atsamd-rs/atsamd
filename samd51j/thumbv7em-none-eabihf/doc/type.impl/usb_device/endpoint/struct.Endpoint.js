(function() {
    var type_impls = Object.fromEntries([["usb_device",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Endpoint%3C'_,+B,+D%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#120-176\">Source</a><a href=\"#impl-Endpoint%3C'_,+B,+D%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B: <a class=\"trait\" href=\"usb_device/bus/trait.UsbBus.html\" title=\"trait usb_device::bus::UsbBus\">UsbBus</a>, D: <a class=\"trait\" href=\"usb_device/endpoint/trait.EndpointDirection.html\" title=\"trait usb_device::endpoint::EndpointDirection\">EndpointDirection</a>&gt; <a class=\"struct\" href=\"usb_device/endpoint/struct.Endpoint.html\" title=\"struct usb_device::endpoint::Endpoint\">Endpoint</a>&lt;'_, B, D&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.address\" class=\"method\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#148-150\">Source</a><h4 class=\"code-header\">pub fn <a href=\"usb_device/endpoint/struct.Endpoint.html#tymethod.address\" class=\"fn\">address</a>(&amp;self) -&gt; <a class=\"struct\" href=\"usb_device/endpoint/struct.EndpointAddress.html\" title=\"struct usb_device::endpoint::EndpointAddress\">EndpointAddress</a></h4></section></summary><div class=\"docblock\"><p>Gets the endpoint address including direction bit.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ep_type\" class=\"method\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#153-155\">Source</a><h4 class=\"code-header\">pub fn <a href=\"usb_device/endpoint/struct.Endpoint.html#tymethod.ep_type\" class=\"fn\">ep_type</a>(&amp;self) -&gt; <a class=\"enum\" href=\"usb_device/endpoint/enum.EndpointType.html\" title=\"enum usb_device::endpoint::EndpointType\">EndpointType</a></h4></section></summary><div class=\"docblock\"><p>Gets the endpoint transfer type.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max_packet_size\" class=\"method\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#158-160\">Source</a><h4 class=\"code-header\">pub fn <a href=\"usb_device/endpoint/struct.Endpoint.html#tymethod.max_packet_size\" class=\"fn\">max_packet_size</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/core/primitive.u16.html\">u16</a></h4></section></summary><div class=\"docblock\"><p>Gets the maximum packet size for the endpoint.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.interval\" class=\"method\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#163-165\">Source</a><h4 class=\"code-header\">pub fn <a href=\"usb_device/endpoint/struct.Endpoint.html#tymethod.interval\" class=\"fn\">interval</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/core/primitive.u8.html\">u8</a></h4></section></summary><div class=\"docblock\"><p>Gets the poll interval for interrupt endpoints.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.stall\" class=\"method\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#168-170\">Source</a><h4 class=\"code-header\">pub fn <a href=\"usb_device/endpoint/struct.Endpoint.html#tymethod.stall\" class=\"fn\">stall</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Sets the STALL condition for the endpoint.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.unstall\" class=\"method\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#173-175\">Source</a><h4 class=\"code-header\">pub fn <a href=\"usb_device/endpoint/struct.Endpoint.html#tymethod.unstall\" class=\"fn\">unstall</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Clears the STALL condition of the endpoint.</p>\n</div></details></div></details>",0,"usb_device::endpoint::EndpointOut","usb_device::endpoint::EndpointIn"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Endpoint%3C'_,+B,+In%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#178-197\">Source</a><a href=\"#impl-Endpoint%3C'_,+B,+In%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B: <a class=\"trait\" href=\"usb_device/bus/trait.UsbBus.html\" title=\"trait usb_device::bus::UsbBus\">UsbBus</a>&gt; <a class=\"struct\" href=\"usb_device/endpoint/struct.Endpoint.html\" title=\"struct usb_device::endpoint::Endpoint\">Endpoint</a>&lt;'_, B, <a class=\"struct\" href=\"usb_device/endpoint/struct.In.html\" title=\"struct usb_device::endpoint::In\">In</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.write\" class=\"method\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#194-196\">Source</a><h4 class=\"code-header\">pub fn <a href=\"usb_device/endpoint/struct.Endpoint.html#tymethod.write\" class=\"fn\">write</a>(&amp;self, data: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/core/primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"usb_device/type.Result.html\" title=\"type usb_device::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/core/primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Writes a single packet of data to the specified endpoint and returns number of bytes\nactually written. The buffer must not be longer than the <code>max_packet_size</code> specified when\nallocating the endpoint.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<p>Note: USB bus implementation errors are directly passed through, so be prepared to handle\nother errors as well.</p>\n<ul>\n<li><a href=\"usb_device/enum.UsbError.html#variant.WouldBlock\" title=\"variant usb_device::UsbError::WouldBlock\"><code>WouldBlock</code></a> - The transmission buffer of the USB\nperipheral is full and the packet cannot be sent now. A peripheral may or may not support\nconcurrent transmission of packets.</li>\n<li><a href=\"usb_device/enum.UsbError.html#variant.BufferOverflow\" title=\"variant usb_device::UsbError::BufferOverflow\"><code>BufferOverflow</code></a> - The data is longer than the\n<code>max_packet_size</code> specified when allocating the endpoint. This is generally an error in\nthe class implementation.</li>\n</ul>\n</div></details></div></details>",0,"usb_device::endpoint::EndpointIn"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Endpoint%3C'_,+B,+Out%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#199-217\">Source</a><a href=\"#impl-Endpoint%3C'_,+B,+Out%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;B: <a class=\"trait\" href=\"usb_device/bus/trait.UsbBus.html\" title=\"trait usb_device::bus::UsbBus\">UsbBus</a>&gt; <a class=\"struct\" href=\"usb_device/endpoint/struct.Endpoint.html\" title=\"struct usb_device::endpoint::Endpoint\">Endpoint</a>&lt;'_, B, <a class=\"struct\" href=\"usb_device/endpoint/struct.Out.html\" title=\"struct usb_device::endpoint::Out\">Out</a>&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read\" class=\"method\"><a class=\"src rightside\" href=\"src/usb_device/endpoint.rs.html#214-216\">Source</a><h4 class=\"code-header\">pub fn <a href=\"usb_device/endpoint/struct.Endpoint.html#tymethod.read\" class=\"fn\">read</a>(&amp;self, data: &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/core/primitive.u8.html\">u8</a>]) -&gt; <a class=\"type\" href=\"usb_device/type.Result.html\" title=\"type usb_device::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/core/primitive.usize.html\">usize</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Reads a single packet of data from the specified endpoint and returns the actual length of\nthe packet. The buffer should be large enough to fit at least as many bytes as the\n<code>max_packet_size</code> specified when allocating the endpoint.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<p>Note: USB bus implementation errors are directly passed through, so be prepared to handle\nother errors as well.</p>\n<ul>\n<li><a href=\"usb_device/enum.UsbError.html#variant.WouldBlock\" title=\"variant usb_device::UsbError::WouldBlock\"><code>WouldBlock</code></a> - There is no packet to be read. Note that\nthis is different from a received zero-length packet, which is valid and significant in\nUSB. A zero-length packet will return <code>Ok(0)</code>.</li>\n<li><a href=\"usb_device/enum.UsbError.html#variant.BufferOverflow\" title=\"variant usb_device::UsbError::BufferOverflow\"><code>BufferOverflow</code></a> - The received packet is too long to\nfit in <code>data</code>. This is generally an error in the class implementation.</li>\n</ul>\n</div></details></div></details>",0,"usb_device::endpoint::EndpointOut"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[9232]}