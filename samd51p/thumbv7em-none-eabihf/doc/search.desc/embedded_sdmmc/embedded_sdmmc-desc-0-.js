searchState.loadedDescShard("embedded_sdmmc", 0, "embedded-sdmmc\nIndicates this file needs archiving (i.e. has been …\nCluster was not properly allocated by the library\nIndicates whether a directory entry is read-only, a …\nMagic value indicating a bad cluster.\nBad block size - only 512 byte blocks supported\nFound a bad cluster\nBad handle given\nCan’t perform this operation with the card in this state\nA standard 512 byte block (also known as a sector).\nThe a number of blocks (or sectors).\nA block device - a device which can read and write blocks …\nThe linear numeric address of a block (or sector).\nWe failed to enable CRC checking on the SD card\nCouldn’t find the card\nIdentifies a cluster on disk.\nWe got a bad response from Command 58\nError while converting types\nWe got a CRC mismatch (card gave us, we calculated)\nIndicates this is a directory.\nYou can’t delete a directory as a file\nThe underlying block device threw an error.\nA directory with that name already exists\nYou can’t open a directory twice\nA directory entry, which tells you about other files and …\nA handle for an open directory on disk, which closes on …\nDisk is full\nMagic value indicating a empty cluster.\nMagic value indicating that the cluster is allocated and …\nTried to read beyond end of file\nAll the ways the functions in this crate can fail.\nThe errors that the <code>BlockDevice</code> can return. Must be debug …\nFAT16/FAT32 formatted volumes.\nIdentifies a FAT16 or FAT32 Volume on the disk.\nA handle for an open file on disk, which closes on drop.\nTried to create an existing file\nYou can’t open a file twice or delete an open file\nTried to create a file with no file name.\nVarious filename related errors that can occur.\nThe given filename was bad\nThe filesystem is badly formatted (or this code is buggy).\nCouldn’t set a GPIO pin\nIndicates the file is hidden.\nMagic value indicating an invalid cluster value.\nTried to create a file with an invalid character.\nBad offset given when seeking\nThis set of flags indicates the file is actually a long …\nMaximum file size supported by this library\nCan’t start a file with a period, or after 8 characters.\nThe different ways we can open a file.\nGiven name was too long (we are limited to 8.3).\nThe given <code>VolumeIdx</code> was bad,\nThe device does not have enough space for the operation\nThat file or directory doesn’t exist\nYou can’t open a directory as a file\nYou can’t open a file as a directory\nIndicates this file cannot be written.\nMagic value indicating the cluster holding the root …\nA handle for an open directory on disk.\nA handle for an open file on disk.\nA partition with a filesystem within it.\nError reading from the card\nOpen a file for reading, if it exists.\nTried to open Read-Only file with write mode\nOpen a file for appending (writing to the end of the …\nCreate a new empty file. Fail if it exists.\nCreate a new empty file, or append to an existing file.\nCreate a new empty file, or truncate an existing file.\nOpen a file and remove all contents, before writing to the …\nWe failed to read the Card Specific Data register\nIndicates this is a system file.\nDriver for an SD Card on an SPI bus.\nThe possible errors this crate can generate.\nAn MS-DOS 8.3 filename. 7-bit ASCII only. All lower-case …\nThings that impl this can tell you the current time.\nWe didn’t get a response when executing this …\nWe didn’t get a response when executing this command\nWe didn’t get a response when reading data from the card\nWe didn’t get a response when waiting for the card to …\nA Gregorian Calendar date/time, in the local time zone.\nOut of memory opening directories\nOut of memory opening files\nOut of memory opening volumes\nWe got an error from the SPI peripheral\nWe can’t do that yet\nJumped to free space during FAT traversing\nCan’t extract utf8 from file name\nIndicates this is a volume label.\nAn open volume on disk, which closes on drop.\nYou can’t open a volume twice\nA number which identifies a volume (or partition) on a …\nWraps a block device and gives access to the FAT-formatted …\nYou can’t close a volume with open files or directories\nThis enum holds the data for the various different types …\nError writing to the card\nThe file attributes (Read Only, Archive, etc)\nGet base name (without extension) of the file.\nTraits and types for working with Block Devices.\nChange to a directory, mutating this object.\nConsume the <code>Directory</code> handle and close it. The behavior of …\nConsume the <code>File</code> handle and close it. The behavior of this …\nConsume the <code>Volume</code> handle and close it. The behavior of …\nClose a directory. You cannot perform operations on an …\nClose a file with the given raw file handle.\nClose a volume\nThe starting cluster of the file. The FAT tells us the …\nThe 512 bytes in this block (or sector).\nCreate a new MS-DOS 8.3 space-padded file name as stored …\nCreate a new MS-DOS 8.3 space-padded file name as stored …\nWhen the file was first created\nDelete a closed file with the given filename, if it exists.\nDelete a closed file with the given filename, if it exists.\nTemporarily get access to the underlying block device.\nThe disk block of this entry\nThe offset on its block (in bytes)\nGet extension of the file (without base name).\nFAT16/FAT32 file system implementation\nCheck if a file is at End Of File.\nGet the length of a file\nGet the current offset of a file\nSeek a file with an offset from the current position.\nSeek a file with an offset back from the end of the file.\nSeek a file with an offset from the start of the file.\nGeneric File System structures\nLook in a directory for a named file.\nLook in a directory for a named file.\nFlush any written data by updating the directory entry.\nFlush (update the entry) for a file with the given raw …\nConsume self and return BlockDevice and TimeSource\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Timestamp</code> from year/month/day/hour/minute/second.\nCreate a <code>Timestamp</code> from the 16-bit FAT date and time …\nReturns the current time\nCheck if any files or folders are open.\nThe number of hours past midnight\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoes this need archiving?\nDoes this entry point at a directory?\nCheck if a file is at End Of File.\nDoes this file has the hidden attribute set?\nIs this a long file name fragment?\nDoes this file has the read-only attribute set?\nDoes this file has the system attribute set?\nDoes this file has the volume attribute set?\nCall a callback function for each directory entry in a …\nCall a callback function for each directory entry in a …\nGet the length of a file\nMake a directory inside this directory\nCreate a directory in a given directory.\nThe number of minutes past the hour\nWhen the file was last modified\nThe name of the file\nCreate a new <code>Directory</code> from a <code>RawDirectory</code>\nCreate a new <code>File</code> from a <code>RawFile</code>\nCreate a new <code>Volume</code> from a <code>RawVolume</code>\nCreate a new Volume Manager using a generic <code>BlockDevice</code>. …\nCreate a new Volume Manager using a generic <code>BlockDevice</code>. …\nDetermine how many blocks this device can hold.\nDetermine how many blocks this device can hold.\nGet the current offset of a file\nOpen a directory.\nOpen a directory.\nOpen a file with the given full path. A file can only be …\nOpen a file with the given full path. A file can only be …\nGet a volume (or partition) based on entries in the Master …\nOpen the volume’s root directory.\nOpen the volume’s root directory.\nGet a volume (or partition) based on entries in the Master …\nGet a short file name containing “..”, which means “…\nRead one or more blocks, starting at the given block index.\nRead from the file\nRead one or more blocks, starting at the given block index.\nRead from an open file.\nImplements the BlockDevice trait for an SD/MMC Protocol …\nThe number of seconds past the minute\nSeek a file with an offset from the current position.\nSeek a file with an offset back from the end of the file.\nSeek a file with an offset from the start of the file.\nSerialize a <code>Timestamp</code> to FAT format\nThe size of the file in bytes.\nGet a short file name containing “.”, which means “…\nConvert a raw directory into a droppable <code>Directory</code>\nConvert a raw file into a droppable <code>File</code>\nConvert back to a raw directory\nConvert back to a raw file\nConvert back to a raw volume\nConvert a raw volume into a droppable <code>Volume</code>\nWrite a new entry in the FAT\nWrite one or more blocks, starting at the given block …\nWrite to the file\nWrite one or more blocks, starting at the given block …\nWrite to a open file.\nAdd 1970 to this file to get the calendar year\nAdd one to this value to get the calendar day\nAdd one to this value to get the calendar month\nA standard 512 byte block (also known as a sector).\nThe a number of blocks (or sectors).\nA block device - a device which can read and write blocks …\nThe linear numeric address of a block (or sector).\nAn iterator returned from <code>Block::range</code>.\nThe errors that the <code>BlockDevice</code> can return. Must be debug …\nAll our blocks are a fixed length of 512 bytes. We do not …\nSometimes we want <code>LEN</code> as a <code>u32</code> and the casts don’t look …\nThe 512 bytes in this block (or sector).\nReturns the argument unchanged.\nHow many blocks are required to hold this many bytes.\nCalls <code>U::from(self)</code>.\nConvert a block index into a 64-bit byte offset from the …\nCreate a new <code>BlockIter</code>, from the given start block, …\nCreate a new block full of zeros.\nDetermine how many blocks this device can hold.\nTake a number of blocks and increment by the integer …\nCreate an iterator from the current <code>BlockIdx</code> through the …\nRead one or more blocks, starting at the given block index.\nWrite one or more blocks, starting at the given block …\nA Boot Parameter Block.\nFAT16 Format\nFat16 Format\nFAT16 specific data\nFAT32 Format\nFat32 Format\nFAT32 specific data\nIndentifies the supported types of FAT format\nIndentifies the supported types of FAT format\nIdentifies a FAT16 or FAT32 Volume on the disk.\nFile System Information structure is only present on FAT32 …\nA 32-byte directory entry as stored on-disk in a directory …\nNumber of entries reserved at the start of a File …\nThe name given to a particular FAT formatted volume.\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nAttempt to parse a Boot Parameter Block from a 512 byte …\nTry and create a new Info Sector from a block.\nGet the value from the $name field\nGet the size of the File Allocation Table in blocks.\nGet the value from the $name field\nGet the $name field\nGet the $name field\nWhich cluster, if any, does this file start at? Assumes …\nGet the value from the $name field\nGet the value from the $name field\nGet the $name field\nGet the value from the $name field\nReturn how many free clusters are left in this volume, if …\nGet the $name field\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the value from the $name field\nOn a FAT32 volume, return the free block count from the …\nGet the value from the $name field\nConvert the on-disk format into a DirEntry\nGet the $name field\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this the last entry in the directory?\nIs this a Long Filename entry?\nIs this a valid entry?\nGet the value from the $name field\nGet the $name field\nIf this is an LFN, get the contents so we can re-assemble …\nDoes this on-disk entry match the given filename?\nGet the value from the $name field\nCreate a new on-disk directory entry from a block of 32 …\nCreate a new VolumeName\nGet the $name field\nReturn the number of the next free cluster, if known.\nGet the value from the $name field\nGet the value from the $name field\nGet the OEM name string for this volume\nLoad the boot parameter block from the start of the given …\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the $name field\nGet the total number of blocks in this filesystem.\nGet the value from the $name field\nGet the $name field\nGet the total number of clusters in this filesystem.\nGet the $name field\nGet the Volume Label string for this volume\nGet the value from the $name field\nGet the value from the $name field\nIndicates whether a directory entry is read-only, a …\nIdentifies a cluster on disk.\nA directory entry, which tells you about other files and …\nA handle for an open directory on disk, which closes on …\nA handle for an open file on disk, which closes on drop.\nErrors related to file operations\nTried to create a file with no file name.\nVarious filename related errors that can occur.\nTried to create a file with an invalid character.\nTried to use an invalid offset.\nMaximum file size supported by this library\nCan’t start a file with a period, or after 8 characters.\nThe different ways we can open a file.\nGiven name was too long (we are limited to 8.3).\nA handle for an open directory on disk.\nA handle for an open file on disk.\nOpen a file for reading, if it exists.\nOpen a file for appending (writing to the end of the …\nCreate a new empty file. Fail if it exists.\nCreate a new empty file, or append to an existing file.\nCreate a new empty file, or truncate an existing file.\nOpen a file and remove all contents, before writing to the …\nUnique ID used to search for files and directories in the …\nA Search ID generator.\nAn MS-DOS 8.3 filename. 7-bit ASCII only. All lower-case …\nThings that impl this can tell you the current time.\nA Gregorian Calendar date/time, in the local time zone.\nDescribes things we can convert to short 8.3 filenames\nCan’t extract utf8 from file name\nThe file attributes (Read Only, Archive, etc)\nThe starting cluster of the file. The FAT tells us the …\nWhen the file was first created\nThe disk block of this entry\nThe offset on its block (in bytes)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a new, unique <code>SearchId</code>.\nReturns the current time\nThe number of hours past midnight\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe number of minutes past the hour\nWhen the file was last modified\nThe name of the file\nCreate a new generator of Search IDs.\nThe number of seconds past the minute\nThe size of the file in bytes.\nTry and convert this value into a <code>ShortFileName</code>.\nAdd 1970 to this file to get the calendar year\nAdd one to this value to get the calendar day\nAdd one to this value to get the calendar month\nOptions for acquiring the card.\nCan’t perform this operation with the card in this state\nWe failed to enable CRC checking on the SD card\nCouldn’t find the card\nThe different types of card we support.\nWe got a bad response from Command 58\nWe got a CRC mismatch (card gave us, we calculated)\nThe possible errors this crate can generate.\nCouldn’t set a GPIO pin\nError reading from the card\nWe failed to read the Card Specific Data register\nAn standard-capacity SD Card supporting v1.x of the …\nAn standard-capacity SD Card supporting v2.x of the …\nAn high-capacity ‘SDHC’ Card.\nDriver for an SD Card on an SPI bus.\nWe didn’t get a response when executing this …\nWe didn’t get a response when executing this command\nWe didn’t get a response when reading data from the card\nWe didn’t get a response when waiting for the card to …\nWe got an error from the SPI peripheral\nError writing to the card\nSets the number of times we will retry to acquire the card …\nCan this card erase single blocks?\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the card type.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTell the driver the card has been initialised.\nMark the card as requiring a reset.\nCreate a new SD/MMC Card driver using a raw SPI interface.\nConstruct a new SD/MMC Card driver, using a raw SPI …\nReturn the usable size of this SD card in bytes.\nConstants from the SD Specifications\nGet a temporary borrow on the underlying SPI device.\nSet to true to enable CRC checking on reading/writing …\nPre-erased before writing\nSD_SEND_OP_COMD - Sends host capacity support information …\nGO_IDLE_STATE - init card in spi mode if CS low\nSTOP_TRANSMISSION - end multiple block read sequence\nSEND_STATUS - read the card status register\nREAD_SINGLE_BLOCK - read a single data block from the card\nREAD_MULTIPLE_BLOCK - read a multiple data blocks from the …\nWRITE_BLOCK - write a single data block to the card\nWRITE_MULTIPLE_BLOCK - write blocks of data until a …\nAPP_CMD - escape for application specific command\nREAD_OCR - read the OCR register of a card\nCRC_ON_OFF - enable or disable CRC checking\nSEND_IF_COND - verify SD Memory Card interface operating …\nSEND_CSD - read the Card Specific Data (CSD register)\nCard Specific Data\nCard Specific Data, version 1\nCard Specific Data, version 2\nwrite data accepted token\nmask for data response tokens after a write block operation\nstart data token for read or write single block*/\nCard indicates last operation was a success\nstatus for card in the idle state\nstatus bit for illegal command\nstatus for card in the ready state\nstop token for write multiple blocks*/\nA version 1 CSD\nA version 2 CSD\nstart data token for write multiple blocks*/\nReturns the card capacity in 512-byte blocks\nReturns the card capacity in 512-byte blocks\nReturns the card capacity in bytes\nReturns the card capacity in bytes\nGets the value from the $name field\nGets the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nPerform the X25 CRC calculation, as used for data blocks.\nPerform the 7-bit CRC used on the SD card\nGet the value from the $name field\nGet the value from the $name field\nThe 16-bytes of data in this Card Specific Data block\nThe 16-bytes of data in this Card Specific Data block\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGets the value from the $name field\nGets the value from the $name field\nGets the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGets the value from the $name field\nGets the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGets the value from the $name field\nGets the value from the $name field\nCreate a new, empty, CSD\nCreate a new, empty, CSD\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field\nGet the value from the $name field")